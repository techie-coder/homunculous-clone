{"id":"node_modules/three/examples/jsm/postprocessing/EffectComposer.js","dependencies":[{"name":"/Users/s4swata/Projects/Lopt/frontend/package.json","includedInParent":true,"mtime":1744624320180},{"name":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/package.json","includedInParent":true,"mtime":1744624308174},{"name":"three","loc":{"line":7,"column":7,"index":82},"parent":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/EffectComposer.js","resolved":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/build/three.module.js"},{"name":"../shaders/CopyShader.js","loc":{"line":8,"column":27,"index":118},"parent":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/EffectComposer.js","resolved":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/shaders/CopyShader.js"},{"name":"./ShaderPass.js","loc":{"line":9,"column":27,"index":173},"parent":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/EffectComposer.js","resolved":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/ShaderPass.js"},{"name":"./MaskPass.js","loc":{"line":10,"column":40,"index":232},"parent":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/EffectComposer.js","resolved":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/examples/jsm/postprocessing/MaskPass.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EffectComposer = void 0;\nvar _three = require(\"three\");\nvar _CopyShader = require(\"../shaders/CopyShader.js\");\nvar _ShaderPass = require(\"./ShaderPass.js\");\nvar _MaskPass = require(\"./MaskPass.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Used to implement post-processing effects in three.js.\n * The class manages a chain of post-processing passes to produce the final visual result.\n * Post-processing passes are executed in order of their addition/insertion.\n * The last pass is automatically rendered to screen.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * ```js\n * const composer = new EffectComposer( renderer );\n *\n * // adding some passes\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n *\n * const glitchPass = new GlitchPass();\n * composer.addPass( glitchPass );\n *\n * const outputPass = new OutputPass()\n * composer.addPass( outputPass );\n *\n * function animate() {\n *\n * \tcomposer.render(); // instead of renderer.render()\n *\n * }\n * ```\n */\nvar EffectComposer = exports.EffectComposer = /*#__PURE__*/function () {\n  /**\n   * Constructs a new effect composer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\n   * be used as the internal read and write buffers. If not given, the composer creates\n   * the buffers automatically.\n   */\n  function EffectComposer(renderer, renderTarget) {\n    _classCallCheck(this, EffectComposer);\n    /**\n     * The renderer.\n     *\n     * @type {WebGLRenderer}\n     */\n    this.renderer = renderer;\n    this._pixelRatio = renderer.getPixelRatio();\n    if (renderTarget === undefined) {\n      var size = renderer.getSize(new _three.Vector2());\n      this._width = size.width;\n      this._height = size.height;\n      renderTarget = new _three.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {\n        type: _three.HalfFloatType\n      });\n      renderTarget.texture.name = 'EffectComposer.rt1';\n    } else {\n      this._width = renderTarget.width;\n      this._height = renderTarget.height;\n    }\n    this.renderTarget1 = renderTarget;\n    this.renderTarget2 = renderTarget.clone();\n    this.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n    /**\n     * A reference to the internal write buffer. Passes usually write\n     * their result into this buffer.\n     *\n     * @type {WebGLRenderTarget}\n     */\n    this.writeBuffer = this.renderTarget1;\n\n    /**\n     * A reference to the internal read buffer. Passes usually read\n     * the previous render result from this buffer.\n     *\n     * @type {WebGLRenderTarget}\n     */\n    this.readBuffer = this.renderTarget2;\n\n    /**\n     * Whether the final pass is rendered to the screen (default framebuffer) or not.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.renderToScreen = true;\n\n    /**\n     * An array representing the (ordered) chain of post-processing passes.\n     *\n     * @type {Array<Pass>}\n     */\n    this.passes = [];\n\n    /**\n     * A copy pass used for internal swap operations.\n     *\n     * @private\n     * @type {ShaderPass}\n     */\n    this.copyPass = new _ShaderPass.ShaderPass(_CopyShader.CopyShader);\n    this.copyPass.material.blending = _three.NoBlending;\n\n    /**\n     * The intenral clock for managing time data.\n     *\n     * @private\n     * @type {Clock}\n     */\n    this.clock = new _three.Clock();\n  }\n\n  /**\n   * Swaps the internal read/write buffers.\n   */\n  return _createClass(EffectComposer, [{\n    key: \"swapBuffers\",\n    value: function swapBuffers() {\n      var tmp = this.readBuffer;\n      this.readBuffer = this.writeBuffer;\n      this.writeBuffer = tmp;\n    }\n\n    /**\n     * Adds the given pass to the pass chain.\n     *\n     * @param {Pass} pass - The pass to add.\n     */\n  }, {\n    key: \"addPass\",\n    value: function addPass(pass) {\n      this.passes.push(pass);\n      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n    }\n\n    /**\n     * Inserts the given pass at a given index.\n     *\n     * @param {Pass} pass - The pass to insert.\n     * @param {number} index - The index into the pass chain.\n     */\n  }, {\n    key: \"insertPass\",\n    value: function insertPass(pass, index) {\n      this.passes.splice(index, 0, pass);\n      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n    }\n\n    /**\n     * Removes the given pass from the pass chain.\n     *\n     * @param {Pass} pass - The pass to remove.\n     */\n  }, {\n    key: \"removePass\",\n    value: function removePass(pass) {\n      var index = this.passes.indexOf(pass);\n      if (index !== -1) {\n        this.passes.splice(index, 1);\n      }\n    }\n\n    /**\n     * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\n     *\n     * @param {number} passIndex - The pass index.\n     * @return {boolean} Whether the the pass for the given index is the last pass in the pass chain.\n     */\n  }, {\n    key: \"isLastEnabledPass\",\n    value: function isLastEnabledPass(passIndex) {\n      for (var i = passIndex + 1; i < this.passes.length; i++) {\n        if (this.passes[i].enabled) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Executes all enabled post-processing passes in order to produce the final frame.\n     *\n     * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\n     * its own time delta value.\n     */\n  }, {\n    key: \"render\",\n    value: function render(deltaTime) {\n      // deltaTime value is in seconds\n\n      if (deltaTime === undefined) {\n        deltaTime = this.clock.getDelta();\n      }\n      var currentRenderTarget = this.renderer.getRenderTarget();\n      var maskActive = false;\n      for (var i = 0, il = this.passes.length; i < il; i++) {\n        var pass = this.passes[i];\n        if (pass.enabled === false) continue;\n        pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n        if (pass.needsSwap) {\n          if (maskActive) {\n            var context = this.renderer.getContext();\n            var stencil = this.renderer.state.buffers.stencil;\n\n            //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n            stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);\n            this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n\n            //context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n            stencil.setFunc(context.EQUAL, 1, 0xffffffff);\n          }\n          this.swapBuffers();\n        }\n        if (_MaskPass.MaskPass !== undefined) {\n          if (pass instanceof _MaskPass.MaskPass) {\n            maskActive = true;\n          } else if (pass instanceof _MaskPass.ClearMaskPass) {\n            maskActive = false;\n          }\n        }\n      }\n      this.renderer.setRenderTarget(currentRenderTarget);\n    }\n\n    /**\n     * Resets the internal state of the EffectComposer.\n     *\n     * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\n     * the one from the constructor. If set, it is used to setup the read and write buffers.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset(renderTarget) {\n      if (renderTarget === undefined) {\n        var size = this.renderer.getSize(new _three.Vector2());\n        this._pixelRatio = this.renderer.getPixelRatio();\n        this._width = size.width;\n        this._height = size.height;\n        renderTarget = this.renderTarget1.clone();\n        renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n      }\n      this.renderTarget1.dispose();\n      this.renderTarget2.dispose();\n      this.renderTarget1 = renderTarget;\n      this.renderTarget2 = renderTarget.clone();\n      this.writeBuffer = this.renderTarget1;\n      this.readBuffer = this.renderTarget2;\n    }\n\n    /**\n     * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\n     * this method honors the current pixel ration.\n     *\n     * @param {number} width - The width in logical pixels.\n     * @param {number} height - The height in logical pixels.\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this._width = width;\n      this._height = height;\n      var effectiveWidth = this._width * this._pixelRatio;\n      var effectiveHeight = this._height * this._pixelRatio;\n      this.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n      this.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n      for (var i = 0; i < this.passes.length; i++) {\n        this.passes[i].setSize(effectiveWidth, effectiveHeight);\n      }\n    }\n\n    /**\n     * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\n     * Setting the pixel ratio will automatically resize the composer.\n     *\n     * @param {number} pixelRatio - The pixel ratio to set.\n     */\n  }, {\n    key: \"setPixelRatio\",\n    value: function setPixelRatio(pixelRatio) {\n      this._pixelRatio = pixelRatio;\n      this.setSize(this._width, this._height);\n    }\n\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever the composer is no longer used in your app.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTarget1.dispose();\n      this.renderTarget2.dispose();\n      this.copyPass.dispose();\n    }\n  }]);\n}();"},"sourceMaps":null,"error":null,"hash":"e31f206e83e83d86221329d4ca9856c1","cacheData":{"env":{}}}
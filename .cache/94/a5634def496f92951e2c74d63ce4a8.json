{"id":"js/CustomPass.js","dependencies":[{"name":"/Users/s4swata/Projects/Lopt/frontend/package.json","includedInParent":true,"mtime":1744624320180},{"name":"three","loc":{"line":1,"column":24,"index":24},"parent":"/Users/s4swata/Projects/Lopt/frontend/js/CustomPass.js","resolved":"/Users/s4swata/Projects/Lopt/frontend/node_modules/three/build/three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CustomPass = void 0;\nvar _three = require(\"three\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/** @module DotScreenShader */\n\n/**\n * Dot screen shader based on [glfx.js sepia shader]{@link https://github.com/evanw/glfx.js}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nvar CustomPass = exports.CustomPass = {\n  name: \"DotScreenShader\",\n  uniforms: _defineProperty({\n    tDiffuse: {\n      value: null\n    },\n    time: {\n      value: 0\n    },\n    scale: {\n      value: 1\n    },\n    progress: {\n      value: 0\n    },\n    tSize: {\n      value: new _three.Vector2(256, 256)\n    },\n    center: {\n      value: new _three.Vector2(0.5, 0.5)\n    },\n    angle: {\n      value: 1.57\n    }\n  }, \"scale\", {\n    value: 1\n  }),\n  vertexShader: /* glsl */\"\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\tuniform vec2 center;\\n\\t\\tuniform float angle;\\n    uniform float time;\\n    uniform float scale;\\n    uniform float progress;\\n\\t\\tuniform vec2 tSize;\\n\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tfloat pattern() {\\n\\n\\t\\t\\tfloat s = sin( angle ), c = cos( angle );\\n\\n\\t\\t\\tvec2 tex = vUv * tSize - center;\\n\\t\\t\\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\\n\\n\\t\\t\\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n            vec2 newUV = vUv;\\n\\n            //newUV = vUv + 0.1*vec2(sin(10. * vUv.x), sin(10.*vUv.y));\\n\\n            vec2 p = 1.*vUv - vec2(0.5);\\n\\n\\n            p += 0.1*cos(scale*3.*p.yx + time + vec2(1.2, 3.4));\\n            p += 0.1*cos(scale*3.7*p.yx + 1.4*time + vec2(2.2, 3.4));\\n            p += 0.1*cos(scale*5.*p.yx + 2.6*time + vec2(4.2, 1.4));\\n            p += 0.3*cos(scale*7.*p.yx + 2.6*time + vec2(10.2, 3.4));\\n\\n\\n\\t\\t\\t//newUV = vUv + centeredUV*vec2(1.,0.);\\n\\n            newUV.x = mix(vUv.x, length(p), progress);\\n            newUV.y = mix(vUv.y, 0., progress);\\n\\n            vec4 color = texture2D( tDiffuse, newUV );\\n\\n\\t\\t\\t//float average = ( color.r + color.g + color.b ) / 3.0;\\n\\n\\t\\t\\t//gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\\n            gl_FragColor = color;\\n            //gl_FragColor = vec4(length(p), 0.,0.,1.);\\n\\n\\t\\t}\"\n};"},"sourceMaps":null,"error":null,"hash":"62b7e93a6d61e05e9abc6712bb3e767c","cacheData":{"env":{}}}